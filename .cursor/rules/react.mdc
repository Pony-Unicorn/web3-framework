---
description: React best practices and patterns for modern web applications
globs: app/**/*.tsx
alwaysApply: true
---

# React Best Practices

## TypeScript Usage

- Use **TypeScript** for all files — no JavaScript is allowed.
- Prefer `interface` over `type` for object shape definitions, especially for component props.
- Avoid using `enum`; use **object maps** or `union types` for better flexibility and tree-shaking.
- Define all components as **typed functional components** using `FC<Props>` or explicit props typing.

## Naming Conventions

- Use **kebab-case** for filenames (e.g. `new-component.tsx`).
- Prefer **named exports** for components instead of default exports.
- Place all components inside the top-level `components/` directory.
- Organize the `components/` directory into the following subfolders:

  - `ui/`: Auto-generated UI components from `shadcn/ui`. **Do not edit manually** — these are managed by the generator.
  - `layouts/`: Page layout components such as `MainLayout`, `AuthLayout`.
  - `shared/`: Components reused across multiple pages, such as `Header`, `Footer`.
  - `elements/`: Small, reusable functional components like `Modal`, `Toast`, `Loading`.

## Component Structure
- Use functional components over class components
- Keep components small and focused
- Extract reusable logic into custom hooks
- Use composition over inheritance
- Split large components into smaller, focused ones

## Hooks
- Follow the Rules of Hooks
- Use custom hooks for reusable logic
- Keep hooks focused and simple
- Use appropriate dependency arrays in useEffect
- Implement cleanup in useEffect when needed
- Avoid nested hooks

## State Management
- Use useState for local component state
- Implement useReducer for complex state logic
- Use Context API for shared state
- Keep state as close to where it's used as possible
- Avoid prop drilling through proper state management
- Use state management libraries only when necessary

## Performance
- Implement proper memoization (useMemo, useCallback)
- Use React.memo for expensive components
- Avoid unnecessary re-renders
- Implement proper lazy loading
- Use proper key props in lists
- Profile and optimize render performance

## Forms

- Use **controlled components** for all form inputs.
- Manage forms using `react-hook-form` as the standard library.
- Perform validation with `Zod` using the `zodResolver` integration.
- Handle submission states (`loading`, `success`, `error`) explicitly using component state.
- Display clear and accessible **loading indicators** and **error messages** to guide the user.
- Ensure **accessibility** by adding proper labels, focus control, and ARIA attributes.

## Error Handling
- Implement Error Boundaries
- Handle async errors properly
- Show user-friendly error messages
- Implement proper fallback UI
- Log errors appropriately
- Handle edge cases gracefully

## Accessibility
- Use semantic HTML elements
- Implement proper ARIA attributes
- Ensure keyboard navigation
- Test with screen readers
- Handle focus management
- Provide proper alt text for images

## Code Organization
- Group related components together
- Use proper file naming conventions
- Implement proper directory structure
- Keep styles close to components
- Use proper imports/exports
- Document complex component logic 